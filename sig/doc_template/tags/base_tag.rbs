module DocTemplate
  module Tags
    class BaseTag
      SOFT_RETURN_RE: ::Regexp

      UNICODE_SPACES_RE: ::Regexp

      attr_reader anchor: untyped

      attr_reader content: untyped

      def self.parse: (untyped node, ?::Hash[untyped, untyped] opts) -> untyped

      def self.tag_with_html_regexp: () -> untyped

      def self.template_path_for: (untyped name) -> untyped

      #
      # Precede the specified element with tag's placeholder
      #
      def before_tag: (untyped node) -> untyped

      def check_tag_soft_return: (untyped node) -> (nil | untyped)

      def content_until_break: (untyped node) -> untyped

      def content_until_materials: (untyped node) -> untyped

      def ela2?: (untyped metadata) -> untyped

      def ela6?: (untyped metadata) -> untyped

      def gdoc?: (untyped opts) -> untyped

      def include_break?: (untyped node) -> untyped

      def include_break_for?: (untyped node, untyped key) -> (false | untyped)

      def materials: () -> untyped

      def parse: (untyped node, ?::Hash[untyped, untyped] _opts) -> self

      def parse_nested: (untyped node, ?::Hash[untyped, untyped] opts) -> untyped

      def parse_template: (untyped context, untyped template_name) -> untyped

      def placeholder: () -> untyped

      def placeholder_id: () -> untyped

      def render: () -> untyped

      #
      # Replace the tag element with its placeholder. Or inline the
      # tag if requested
      #
      def replace_tag: (untyped node) -> untyped

      def tag_data: () -> ::Hash[untyped, untyped]

      #
      # First look for the template override inside possible gems
      # And use standard one if not found
      #
      def template_name: (untyped opts) -> untyped

      def template_path: (untyped name) -> untyped

      private

      def remove_tag: () -> untyped
    end
  end
end
